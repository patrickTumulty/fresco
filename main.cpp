//
// Created by Patrick Tumulty on 5/15/22.
//

#include "HeaderFileBuilder.h"
#include "FileUtils.h"
#include "Logger.h"
#include "ArgProcessor.h"
#include "InputProcessor.h"
#include <iostream>
#include <queue>
#include <filesystem>

static int version = 0x0100; // v1.00

struct DataItem
{
    std::string varName;
    std::string filename;
};

static std::string outputFilename;
static std::string outputDirectory;
static std::vector<DataItem> dataItems;


void printHelpExample();
void processInputFileArguments(std::vector<DataItem> &headerDataItems, HeaderFileBuilder &writer);
void printVersion();
void writeHeaderFile();
int verifyInputs();

std::vector<ArgProcessor> getArgProcessors()
{
    std::vector<ArgProcessor> processors;

    processors.emplace_back("--version", "", ARG_PROCESSOR_FLAG, [](const std::vector<std::string>& values)
    {
        printVersion();
        return 0;
    });

    processors.emplace_back("--header", "-h", 1, [](const std::vector<std::string>& values)
    {
        outputFilename = values[0];
        return 0;
    });

    processors.emplace_back("--dir", "-d", 1, [](const std::vector<std::string>& values)
    {
        outputDirectory = values[0];

        if (!std::filesystem::exists(outputDirectory))
        {
            Logger::get().consoleLog("Could not access " + outputDirectory);
            return -1;
        }

        return 0;
    });

    processors.emplace_back("--files", "-f", ARG_PROCESSOR_FINAL, [](const std::vector<std::string>& values)
    {
        if (values.size() % 2 != 0)
        {
            Logger::get().consoleLog("Invalid number of arguments");
            return -1;
        }

        for (int i = 0; i < values.size(); i+= 2)
        {
            DataItem item;
            item.varName = values[i];
            item.filename = values[i + 1];
            dataItems.push_back(item);
        }

        return 0;
    });

    return processors;
}

/**
 * Main
 *
 * @param argc argc
 * @param argv argv
 * @return 0 if successful execution
 */
int main(int argc, char *argv[])
{
    InputProcessor inputProcessor(getArgProcessors());

    inputProcessor.processInputs(argc, argv);

    if (verifyInputs() != 0)
    {
        return -1;
    }

    writeHeaderFile();

    return 0;
}

/**
 * Verify that all necessary inputs have been provided
 *
 * @return 0 if inputs are valid, else -1
 */
int verifyInputs()
{
    if (outputFilename.empty())
    {
        Logger::get().consoleLog("Exiting... No output filename defined");
        return -1;
    }
    else if (outputDirectory.empty())
    {
        Logger::get().consoleLog("Exiting... No output directory specified");
        return -1;
    }
    else if (dataItems.empty())
    {
        Logger::get().consoleLog("Exiting... No files provided");
        return -1;
    }

    return 0;
}

void writeHeaderFile()
{
    HeaderFileBuilder headerBuilder(outputFilename);
    headerBuilder.appendLine();
    headerBuilder.addInclude("cstdint");
    headerBuilder.appendLine();

    std::string commentString = "This file was generated by rhc (Resource Header Compiler).\n"
                                "URL: https://github.com/patrickTumulty/rhc\n"
                                "File Contents:\n";

    for (const DataItem& item : dataItems)
    {
        commentString += "\t" + item.varName + " (" + item.filename + ")\n";
        commentString += "\t" + item.varName + "_length\n";
    }

    headerBuilder.writeMultilineComment(commentString);

    processInputFileArguments(dataItems, headerBuilder);

    headerBuilder.appendLine();
    headerBuilder.endFile();

    FileUtils::writeStringToFile(headerBuilder.getHeaderFileName(), headerBuilder.getFileContents());
}

/**
 * Print rhc version
 */
void printVersion()
{
    printf("rhc v%d.%02d\n", 0xff & version >> 8, 0xff & version);
}

/**
 * Process the input file arguments.
 *
 * Process each file and add it to the output header file
 *
 * @param[in] headerDataItems argument input queue
 * @param[in] writer header file writer
 */
void processInputFileArguments(std::vector<DataItem> &headerDataItems, HeaderFileBuilder &writer)
{
    for (const DataItem& item : headerDataItems)
    {
        try
        {
            std::ifstream fileReader(item.filename, std::ios::binary);
            unsigned long len = std::filesystem::file_size(item.filename);
            char data[len];

            Logger::get().consoleLog(item.filename + " : " + std::to_string(len) + "b");

            fileReader.read(data, (long) len);
            writer.appendLine();
            writer.writeULongVar(item.varName + "_length", len);
            writer.writeArray(item.varName, reinterpret_cast<uint8_t *>(data), len);
            fileReader.close();
        }
        catch (const std::exception& ex)
        {
            Logger::get().logError("Error processing file: " + std::string(ex.what()));
        }
    }
}

/**
 * Print help and example info about this program
 */
void printHelpExample()
{
    std::string example =
            "Resource Header Compiler (rhc)\n\n"
            "\tThe resource header compiler is a simple command line tool used for parsing byte information from\n"
            "\tvarious files into header file defined byte arrays. The resulting header file can then be included\n"
            "\tin any C or C++ project.\n\n"
            "Input Arguments:\n"
            "\t$ rhc <output-filename> [<var-name> <file-path>, ...]\n\n"
            "\toutput-filename               : The name of the output header file.\n"
            "\t[<var-name> <file-path>, ...] : space separated list. The <var-name> is the name that the resulting\n"
            "\t                                byte array will be saved as in the resulting header file. The\n"
            "\t                                <file-path> is the path to read the byte data from.\n"
            "Example:\n"
            "\t$ rhc data_header.h animals animals.txt trees trees.csv photo sunset.png\n";
    std::cout << example << std::endl;
}
