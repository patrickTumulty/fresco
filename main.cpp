//
// Created by Patrick Tumulty on 5/15/22.
//

#include "HeaderFileBuilder.h"
#include "StringUtils.h"
#include "FileUtils.h"
#include "Logger.h"
#include <iostream>
#include <queue>
#include <filesystem>

static int version = 0x0100;

struct DataItem
{
    std::string varName;
    std::string filename;
};

void printHelpExample();
void processInputFileArguments(std::vector<DataItem> &headerDataItems, HeaderFileBuilder &writer);
void printVersion();
std::queue<std::string> createInputQueue(int argc, char *const *argv);
void processAndStripOptions(std::queue<std::string> &inputQueue);

/**
 * Main
 *
 * @param argc argc
 * @param argv argv
 * @return 0 if successful execution
 */
int main(int argc, char *argv[])
{
    std::queue<std::string> inputQueue = createInputQueue(argc, argv);

    processAndStripOptions(inputQueue);

    if ((inputQueue.size() - 1) % 2 != 0)
    {
        Logger::get().consoleLog("Invalid number of arguments");
        return -1;
    }

    std::string outputFilename = inputQueue.front();
    inputQueue.pop();


    std::vector<DataItem> dataItems;

    while (!inputQueue.empty())
    {
        DataItem item;
        item.varName = inputQueue.front();
        inputQueue.pop();
        item.filename = inputQueue.front();
        inputQueue.pop();
        dataItems.push_back(item);
    }

    HeaderFileBuilder headerBuilder(outputFilename);
    headerBuilder.appendLine();
    headerBuilder.addInclude("cstdint");
    headerBuilder.appendLine();

    std::string commentString = "This file was generated by rhc (Resource Header Compiler).\n"
                                "URL: https://github.com/patrickTumulty/rhc\n"
                                "File Contents:\n";
    for (const DataItem& item : dataItems)
    {
        commentString += "\t" + item.varName + " (" + item.filename + ")\n";
        commentString += "\t" + item.varName + "_length\n";
    }

    headerBuilder.writeMultilineComment(commentString);

    processInputFileArguments(dataItems, headerBuilder);

    headerBuilder.appendLine();
    headerBuilder.endFile();

    FileUtils::writeStringToFile(headerBuilder.getHeaderFileName(), headerBuilder.getFileContents());

    return 0;
}

/**
 * Process input options and remove them from the queue. It is expected that the input arguments proceed the main args.
 *
 * @param inputQueue populated input queue
 */
void processAndStripOptions(std::queue<std::string> &inputQueue)
{
    if (inputQueue.empty() || inputQueue.front() == "--help")
    {
        printHelpExample();
    }
    else if (inputQueue.front() == "--version")
    {
        printVersion();
    }
}

/**
 * Create and populate the input queue from the command line arguments
 *
 * @param argc argc
 * @param argv argv
 * @return input queue
 */
std::queue<std::string> createInputQueue(int argc, char *const *argv)
{
    std::queue<std::string> inputQueue;
    for (int i = 0; i < argc; i++)
    {
        inputQueue.push(argv[i]);
    }

    inputQueue.pop(); // remove binary name
    return inputQueue;
}

/**
 * Print rhc version
 */
void printVersion()
{
    printf("rhc v%d.%02d\n", 0xff & version >> 8, 0xff & version);
}

/**
 * Process the input file arguments.
 *
 * Process each file and add it to the output header file
 *
 * @param[in] headerDataItems argument input queue
 * @param[in] writer header file writer
 */
void processInputFileArguments(std::vector<DataItem> &headerDataItems, HeaderFileBuilder &writer)
{
    for (DataItem item : headerDataItems)
    {
        try
        {
            std::ifstream fileReader(item.filename, std::ios::binary);
            unsigned long len = std::filesystem::file_size(item.filename);
            char data[len];

            Logger::get().consoleLog("Reading... " + item.filename + " : " + std::to_string(len) + " bytes");

            fileReader.read(data, (long) len);
            writer.appendLine();
            writer.writeULongVar(item.varName + "_length", len);
            writer.writeArray(item.varName, reinterpret_cast<uint8_t *>(data), len);
            fileReader.close();
        }
        catch (const std::exception& ex)
        {
            Logger::get().logError("Error processing file: " + std::string(ex.what()));
        }
    }
}

/**
 * Print help and example info about this program
 */
void printHelpExample()
{
    std::string example =
            "Resource Header Compiler (rhc)\n\n"
            "\tThe resource header compiler is a simple command line tool used for parsing byte information from\n"
            "\tvarious files into header file defined byte arrays. The resulting header file can then be included\n"
            "\tin any C or C++ project.\n\n"
            "Input Arguments:\n"
            "\t$ rhc <output-filename> [<var-name> <file-path>, ...]\n\n"
            "\toutput-filename               : The name of the output header file.\n"
            "\t[<var-name> <file-path>, ...] : space separated list. The <var-name> is the name that the resulting\n"
            "\t                                byte array will be saved as in the resulting header file. The\n"
            "\t                                <file-path> is the path to read the byte data from.\n"
            "Example:\n"
            "\t$ rhc data_header.h animals animals.txt trees trees.csv photo sunset.png\n";
    std::cout << example << std::endl;
}
